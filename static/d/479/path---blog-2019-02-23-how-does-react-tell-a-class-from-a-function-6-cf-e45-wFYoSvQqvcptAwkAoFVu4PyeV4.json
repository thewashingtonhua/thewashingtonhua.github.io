{"data":{"site":{"siteMetadata":{"title":"童话说","keywords":["tonghuashuo","github","front-end","javascript","typescript","react","node","washington","hua","童话","童话说","前端","博客","技术","计算机","互联网"]}},"markdownRemark":{"html":"<blockquote>\n<p>原文地址：<a target='_blank' href='https://overreacted.io/how-does-react-tell-a-class-from-a-function/'>How Does React Tell a Class from a Function?</a>)</p>\n<p>原文作者：<a target='_blank' href='https://twitter.com/dan_abramov'>Dan Abramov</a></p>\n</blockquote>\n<h1>React 如何区分 Class 和 Function？</h1>\n<p>让我们来看一下这个以函数形式定义的 <code class=\"gatsby-code-text\">Greeting</code> 组件：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Greeting() {\n  return &lt;p&gt;Hello&lt;/p&gt;;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>React 也支持将他定义成一个类：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">class Greeting extends React.Component {\n  render() {\n    return &lt;p&gt;Hello&lt;/p&gt;;\n  }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>（直到 <a href=\"https://reactjs.org/docs/hooks-intro.html\">最近</a>，这是使用 state 特性的唯一方式）</p>\n<p>当你要渲染一个 <code class=\"gatsby-code-text\">&lt;Greeting /&gt;</code> 组件时，你并不需要关心它是如何定义的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// 是类还是函数 —— 无所谓\n&lt;Greeting /&gt;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>但 <strong>React 本身</strong>在意其中的差别！</p>\n<p>如果 <code class=\"gatsby-code-text\">Greeting</code> 是一个函数，React 需要调用它。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// 你的代码\nfunction Greeting() {\n  return &lt;p&gt;Hello&lt;/p&gt;;\n}\n\n// React 内部\nconst result = Greeting(props); // &lt;p&gt;Hello&lt;/p&gt;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但如果 <code class=\"gatsby-code-text\">Greeting</code> 是一个类，React 需要先用 <code class=\"gatsby-code-text\">new</code> 操作符将其实例化，<strong>然后</strong> 调用刚才生成实例的 <code class=\"gatsby-code-text\">render</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// 你的代码\nclass Greeting extends React.Component {\n  render() {\n    return &lt;p&gt;Hello&lt;/p&gt;;\n  }\n}\n\n// React 内部\nconst instance = new Greeting(props); // Greeting {}\nconst result = instance.render(); // &lt;p&gt;Hello&lt;/p&gt;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>无论哪种情况 React 的目标都是去获取渲染后的节点（在这个案例中，<code class=\"gatsby-code-<p\">Hello&lt;/p</code>）。但具体的步骤取决于 <code class=\"gatsby-code-text\">Greeting</code> 是如何定义的。</p>\n<p><strong>所以 React 是怎么知道某样东西是 class 还是 function 的呢？</strong></p>\n<p>就像我 <a href=\"https://overreacted.io/why-do-we-write-super-props/\">上一篇博客</a> 中提到的，<strong>你并不需要知道这个才能高效使用 React。</strong> 我几年来都不知道这个。请不要把这变成一道面试题。事实上，这篇博客更多的是关于 JavaScript 而不是 React。</p>\n<p>这篇博客是写给那些对 React 具体是 <strong>如何</strong> 工作的表示好奇的读者的。你是那样的人吗？那我们一起深入探讨一下吧。</p>\n<p><strong>这将是一段漫长的旅程，系好安全带。这篇文章并没有多少关于 React 本身的信息，但我们会涉及到 <code class=\"gatsby-code-text\">new</code>、<code class=\"gatsby-code-text\">this</code>、<code class=\"gatsby-code-text\">class</code>、箭头函数、<code class=\"gatsby-code-text\">prototype</code>、<code class=\"gatsby-code-text\">__proto__</code>、<code class=\"gatsby-code-text\">instanceof</code> 等方面，以及这些东西是如何在 JavaScript 中一起工作的。幸运的是，你并不需要在使用 React 时一直想着这些，除非你正在实现 React...</strong></p>\n<p>（如果你真的很想知道答案，直接翻到最下面。）</p>\n<hr>\n<p>首先，我们需要理解为什么把函数和类分开处理很重要。注意看我们是怎么使用 <code class=\"gatsby-code-text\">new</code> 操作符来调用一个类的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// 如果 Greeting 是一个函数\nconst result = Greeting(props); // &lt;p&gt;Hello&lt;/p&gt;\n\n// 如果 Greeting 是一个类\nconst instance = new Greeting(props); // Greeting {}\nconst result = instance.render(); // &lt;p&gt;Hello&lt;/p&gt;</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我们来简单看一下 <code class=\"gatsby-code-text\">new</code> 在 JavaScript 是干什么的。</p>\n<hr>\n<p>在过去，JavaScript 还没有类。但是，你可以使用普通函数来模拟。<strong>具体来讲，只要在函数调用前加上 <code class=\"gatsby-code-text\">new</code> 操作符，你就可以把任何函数当做一个类的构造函数来用：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// 只是一个函数\nfunction Person(name) {\n  this.name = name;\n}\n\nvar fred = new Person(&#39;Fred&#39;); // ✅ Person {name: &#39;Fred&#39;}\nvar george = Person(&#39;George&#39;); // 🔴 没用的</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>现在你依然可以这样写！在 DevTools 里试试吧。</p>\n<p>如果你调用 <code class=\"gatsby-code-text\">Person(&#39;Fred&#39;)</code> 时 <strong>没有</strong> 加 <code class=\"gatsby-code-text\">new</code>，其中的 <code class=\"gatsby-code-text\">this</code> 会指向某个全局且无用的东西（比如，<code class=\"gatsby-code-text\">window</code> 或者 <code class=\"gatsby-code-text\">undefined</code>），因此我们的代码会崩溃，或者做一些像设置 <code class=\"gatsby-code-text\">window.name</code> 之类的傻事。</p>\n<p>通过在调用前增加 <code class=\"gatsby-code-text\">new</code>，我们说：“嘿 JavaScript，我知道 <code class=\"gatsby-code-text\">Person</code> 只是个函数，但让我们假装它是个构造函数吧。<strong>创建一个 <code class=\"gatsby-code-text\">{}</code> 对象并把 <code class=\"gatsby-code-text\">Person</code> 中的 <code class=\"gatsby-code-text\">this</code> 指向那个对象，以便我可以通过类似 <code class=\"gatsby-code-text\">this.name</code> 的形式去设置一些东西，然后把这个对象返回给我。</strong>”</p>\n<p>这就是 <code class=\"gatsby-code-text\">new</code> 操作符所做的事。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">var fred = new Person(&#39;Fred&#39;); // 和 `Person` 中的 `this` 等效的对象</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p><code class=\"gatsby-code-text\">new</code> 操作符同时也把我们放在 <code class=\"gatsby-code-text\">Person.prototype</code> 上的东西放到了 <code class=\"gatsby-code-text\">fred</code> 对象上：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHi = function() {  alert(&#39;Hi, I am &#39; + this.name);}\nvar fred = new Person(&#39;Fred&#39;);\nfred.sayHi();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这就是在 JavaScript 直接支持类之前，人们模拟类的方式。</p>\n<hr>\n<p><code class=\"gatsby-code-text\">new</code> 在 JavaScript 中已经存在了好久了，然而类还只是最近的事，它的出现让我们能够重构我们前面的代码以使它更符合我们的本意：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">class Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHi() {\n    alert(&#39;Hi, I am &#39; + this.name);\n  }\n}\n\nlet fred = new Person(&#39;Fred&#39;);\nfred.sayHi();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>捕捉开发者的本意</strong> 是语言和 API 设计中非常重要的一点。</p>\n<p>如果你写了一个函数，JavaScript 没办法判断它应该像 <code class=\"gatsby-code-text\">alert()</code> 一样被调用，还是应该被视作像 <code class=\"gatsby-code-text\">new Person()</code> 一样的构造函数。忘记给像 <code class=\"gatsby-code-text\">Person</code> 这样的函数指定 <code class=\"gatsby-code-text\">new</code> 会导致令人费解的行为。</p>\n<p><strong>类语法允许我们说：“这不仅仅是个函数 —— 这是个类并且它有构造函数”。</strong> 如果你在调用它时忘了加 <code class=\"gatsby-code-text\">new</code>，JavaScript 会报错：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">let fred = new Person(&#39;Fred&#39;);\n// ✅  如果 Person 是个函数：有效\n// ✅  如果 Person 是个类：依然有效\n\nlet george = Person(&#39;George&#39;); // 我们忘记使用 `new`\n// 😳 如果 Person 是个长得像构造函数的方法：令人困惑的行为\n// 🔴 如果 Person 是个类：立即失败</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这可以帮助我们在早期捕捉错误，而不会遇到类似 <code class=\"gatsby-code-text\">this.name</code> 被当成 <code class=\"gatsby-code-text\">window.name</code> 对待而不是 <code class=\"gatsby-code-text\">george.name</code> 的隐晦错误。</p>\n<p>然而，这意味着 React 需要在调用所有类之前加上 <code class=\"gatsby-code-text\">new</code>，而不能把它直接当做一个常规的函数去调用，因为 JavaScript 会把它当做一个错误对待！</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">class Counter extends React.Component {\n  render() {\n    return &lt;p&gt;Hello&lt;/p&gt;;\n  }\n}\n\n// 🔴 React 不能简单这么做：\nconst instance = Counter(props);</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这意味着麻烦。</p>\n<hr>\n<p>在我们看到 React 如何处理这个问题之前，很重要的一点就是要记得大部分 React 的用户会使用 Babel 等编译器来编译类等现代化的特性以便能在老旧的浏览器上运行。因此我们需要在我们的设计中考虑编译器。</p>\n<p>在 Babel 的早期版本中，类不加 <code class=\"gatsby-code-text\">new</code> 也可以被调用。但这个问题已经被修复了 —— 通过生成额外的代码的方式。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Person(name) {\n  // 稍微简化了一下 Babel 的输出：\n  if (!(this instanceof Person)) {\n    throw new TypeError(&quot;Cannot call a class as a function&quot;);\n  }\n  // Our code:\n  this.name = name;\n}\n\nnew Person(&#39;Fred&#39;); // ✅ OK\nPerson(&#39;George&#39;);   // 🔴 无法把类当做函数来调用</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你或许已经在你构建出来的包中见过类似的代码，这就是那些 <code class=\"gatsby-code-text\">_classCallCheck</code> 函数做的事。（你可以通过启用“loose mode”来关闭检查以减小构建包的尺寸，但这或许会使你最终转向真正的原生类时变得复杂）</p>\n<hr>\n<p>至此，你应该已经大致理解了调用时加不加 <code class=\"gatsby-code-text\">new</code> 的差别：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><code class=\"gatsby-code-text\">new Person()</code></th>\n<th><code class=\"gatsby-code-text\">Person()</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"gatsby-code-text\">class</code></td>\n<td>✅ <code class=\"gatsby-code-text\">this</code> 是一个 <code class=\"gatsby-code-text\">Person</code> 实例</td>\n<td>🔴 <code class=\"gatsby-code-text\">TypeError</code></td>\n</tr>\n<tr>\n<td><code class=\"gatsby-code-text\">function</code></td>\n<td>✅ <code class=\"gatsby-code-text\">this</code> 是一个 <code class=\"gatsby-code-text\">Person</code> 实例</td>\n<td>😳 <code class=\"gatsby-code-text\">this</code> 是 <code class=\"gatsby-code-text\">window</code> 或 <code class=\"gatsby-code-text\">undefined</code></td>\n</tr>\n</tbody>\n</table>\n<p>这就是 React 正确调用你的组件很重要的原因。 <strong>如果你的组件被定义为一个类，React 需要使用 <code class=\"gatsby-code-text\">new</code> 来调用它</strong></p>\n<p>所以 React 能检查出某样东西是否是类吗？</p>\n<p>没那么容易！即便我们能够 <a href=\"https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function\">在 JavaScript 中区分类和函数</a>，面对被 Babel 等工具处理过的类这还是没用。对浏览器而言，它们只是不同的函数。这是 React 的不幸。</p>\n<hr>\n<p>好，那 React 可以直接在每次调用时都加上 <code class=\"gatsby-code-text\">new</code> 吗？很遗憾，这种方法并不总是有用。</p>\n<p>对于常规函数，用 <code class=\"gatsby-code-text\">new</code> 调用会给它们一个 <code class=\"gatsby-code-text\">this</code> 作为对象实例。对于用作构造函数的函数（比如我们前面提到的 <code class=\"gatsby-code-text\">Person</code>）是可取的，但对函数组件这或许就比较令人困惑了：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Greeting() {\n  // 我们并不期望 `this` 在这里表示任何类型的实例\n  return &lt;p&gt;Hello&lt;/p&gt;;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这暂且还能忍，还有两个 <strong>其他</strong> 理由会扼杀这个想法。</p>\n<hr>\n<p>关于为什么总是使用 <code class=\"gatsby-code-text\">new</code> 是没用的的第一个理由是，对于原生的箭头函数（不是那些被 Babel 编译过的），用 <code class=\"gatsby-code-text\">new</code> 调用会抛出一个错误：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">const Greeting = () =&gt; &lt;p&gt;Hello&lt;/p&gt;;\nnew Greeting(); // 🔴 Greeting 不是一个构造函数</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>这个行为是遵循箭头函数的设计而刻意为之的。箭头函数的一个附带作用是它 <strong>没有</strong> 自己的 <code class=\"gatsby-code-text\">this</code> 值 —— <code class=\"gatsby-code-text\">this</code> 解析自离得最近的常规函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">class Friends extends React.Component {\n  render() {\n    const friends = this.props.friends;\n    return friends.map(friend =&gt;\n      &lt;Friend\n        // `this` 解析自 `render` 方法\n        size={this.props.size}\n        name={friend.name}\n        key={friend.id}\n      /&gt;\n    );\n  }\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>OK，所以 <strong>箭头函数没有自己的 <code class=\"gatsby-code-text\">this</code>。</strong>但这意味着它作为构造函数是完全无用的！</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">const Person = (name) =&gt; {\n  // 🔴 这么写是没有意义的！\n  this.name = name;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>因此，<strong>JavaScript 不允许用 <code class=\"gatsby-code-text\">new</code> 调用箭头函数。</strong> 如果你这么做，你或许已经犯了错，最好早点告诉你。这和 JavaScript 不让你 <strong>不加</strong> <code class=\"gatsby-code-text\">new</code> 去调用一个类是类似的。</p>\n<p>这样很不错，但这也让我们的计划受阻。React 不能简单对所有东西都使用 <code class=\"gatsby-code-text\">new</code>，因为会破坏箭头函数！我们可以利用箭头函数没有 <code class=\"gatsby-code-text\">prototype</code> 的特点来检测箭头函数，不对它们使用 <code class=\"gatsby-code-text\">new</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">(() =&gt; {}).prototype // undefined\n(function() {}).prototype // {constructor: f}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>但这对于被 Babel 编译过的函数是 <a href=\"https://github.com/facebook/react/issues/4599#issuecomment-136562930\">没用</a> 的。这或许没什么大不了，但还有另一个原因使得这条路不会有结果。</p>\n<hr>\n<p>另一个我们不能总是使用 <code class=\"gatsby-code-text\">new</code> 的原因是它会妨碍 React 支持返回字符串或其它原始类型的组件。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Greeting() {\n  return &#39;Hello&#39;;\n}\n\nGreeting(); // ✅ &#39;Hello&#39;\nnew Greeting(); // 😳 Greeting {}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这，再一次，和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\"><code class=\"gatsby-code-text\">new</code> 操作符</a> 的怪异设计有关。如我们之前所看到的，<code class=\"gatsby-code-text\">new</code> 告诉 JavaScript 引擎去创建一个对象，让这个对象成为函数内部的 <code class=\"gatsby-code-text\">this</code>，然后把这个对象作为 <code class=\"gatsby-code-text\">new</code> 的结果给我们。</p>\n<p>然而，JavaScript 也允许一个使用 <code class=\"gatsby-code-text\">new</code> 调用的函数返回另一个对象以 <strong>覆盖</strong> <code class=\"gatsby-code-text\">new</code> 的返回值。或许，这在我们利用诸如“对象池模式”来对组件进行复用时是被认为有用的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// 创建了一个懒变量 zeroVector = null;\nfunction Vector(x, y) {\n  if (x === 0 &amp;&amp; y === 0) {\n    if (zeroVector !== null) {\n      // 复用同一个实例\n      return zeroVector;\n    }\n    zeroVector = this;\n  }\n  this.x = x;\n  this.y = y;\n}\n\nvar a = new Vector(1, 1);\nvar b = new Vector(0, 0);\nvar c = new Vector(0, 0); // 😲 b === c</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然而，如果一个函数的返回值 <strong>不是</strong> 一个对象，它会被 <code class=\"gatsby-code-text\">new</code> <strong>完全忽略</strong>。如果你返回了一个字符串或数字，就好像完全没有 <code class=\"gatsby-code-text\">return</code> 一样。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Answer() {\n  return 42;\n}\n\nAnswer(); // ✅ 42\nnew Answer(); // 😳 Answer {}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>当使用 <code class=\"gatsby-code-text\">new</code> 调用函数时，是没办法读取原始类型（例如一个数字或字符串）的返回值的。因此如果 React 总是使用 <code class=\"gatsby-code-text\">new</code>，就没办法增加对返回字符串的组件的支持！</p>\n<p>这是不可接受的，因此我们必须妥协。</p>\n<hr>\n<p>至此我们学到了什么？React 在调用类（包括 Babel 输出的）时 <strong>需要用</strong> <code class=\"gatsby-code-text\">new</code>，但在调用常规函数或箭头函数时（包括 Babel 输出的）<strong>不需要用</strong> <code class=\"gatsby-code-text\">new</code>，并且没有可靠的方法来区分这些情况。</p>\n<p><strong>如果我们没法解决一个笼统的问题，我们能解决一个具体的吗？</strong></p>\n<p>当你把一个组件定义为类，你很可能会想要扩展 <code class=\"gatsby-code-text\">React.Component</code> 以便获取内置的方法，比如 <code class=\"gatsby-code-text\">this.setState()</code>。 <strong>与其试图检测所有的类，我们能否只检测 <code class=\"gatsby-code-text\">React.Component</code> 的后代呢？</strong></p>\n<p>剧透：React 就是这么干的。</p>\n<hr>\n<p>或许，检查 <code class=\"gatsby-code-text\">Greeting</code> 是否是一个 React 组件类的最符合语言习惯的方式是测试 <code class=\"gatsby-code-text\">Greeting.prototype instanceof React.Component</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">class A {}\nclass B extends A {}\n\nconsole.log(B.prototype instanceof A); // true</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>我知道你在想什么，刚才发生了什么？！为了回答这个问题，我们需要理解 JavaScript 原型。</p>\n<p>你或许对“原型链”很熟悉。JavaScript 中的每一个对象都有一个“原型”。当我们写 <code class=\"gatsby-code-text\">fred.sayHi()</code> 但 <code class=\"gatsby-code-text\">fred</code> 对象没有 <code class=\"gatsby-code-text\">sayHi</code> 属性，我们尝试到 <code class=\"gatsby-code-text\">fred</code> 的原型上去找 <code class=\"gatsby-code-text\">sayHi</code> 属性。要是我们在这儿找不到，就去找原型链的下一个原型 —— <code class=\"gatsby-code-text\">fred</code> 的原型的原型，以此类推。</p>\n<p><strong>费解的是，一个类或函数的 <code class=\"gatsby-code-text\">prototype</code> 属性 <em>并不</em> 指向那个值的原型。</strong> 我没开玩笑。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Person() {}\n\nconsole.log(Person.prototype); // 🤪 不是 Person 的原型\nconsole.log(Person.__proto__); // 😳 Person 的原型</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>因此“原型链”更像是 <code class=\"gatsby-code-text\">__proto__.__proto__.__proto__</code> 而不是 <code class=\"gatsby-code-text\">prototype.prototype.prototype</code>，我花了好几年才搞懂这一点。</p>\n<p>那么函数和类的 <code class=\"gatsby-code-text\">prototype</code> 属性又是什么？<strong>是用 <code class=\"gatsby-code-text\">new</code> 调用那个类或函数生成的所有对象的 <code class=\"gatsby-code-text\">__proto__</code> ！</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">function Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHi = function() {\n  alert(&#39;Hi, I am &#39; + this.name);\n}\n\nvar fred = new Person(&#39;Fred&#39;); // 设置 `fred.__proto__` 为 `Person.prototype`</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>那个 <code class=\"gatsby-code-text\">__proto__</code> 链才是 JavaScript 用来查找属性的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">fred.sayHi();\n// 1. fred 有 sayHi 属性吗？不。\n// 2. fred.__proto__ 有 sayHi 属性吗？是的，调用它！\n\nfred.toString();\n// 1. fred 有 toString 属性吗？不。\n// 2. fred.__proto__ 有 toString 属性吗？不。\n// 3. fred.__proto__.__proto__ 有 toString 属性吗？是的，调用它！</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在实战中，你应该几乎永远不需要直接在代码里动到 <code class=\"gatsby-code-text\">__proto__</code> 除非你在调试和原型链相关的问题。如果你想让某样东西在 <code class=\"gatsby-code-text\">fred.__proto__</code> 上可用，你应该把它放在 <code class=\"gatsby-code-text\">Person.prototype</code>，至少它最初是这么设计的。</p>\n<p><code class=\"gatsby-code-text\">__proto__</code> 属性甚至一开始就不应该被浏览器暴露出来，因为原型链应该被视为一个内部概念，然而某些浏览器增加了 <code class=\"gatsby-code-text\">__proto__</code> 并最终勉强被标准化（但已被废弃并推荐使用 <code class=\"gatsby-code-text\">Object.getPrototypeOf()</code>）。</p>\n<p><strong>然而一个名叫“原型”的属性却给不了我一个值的“原型”这一点还是很让我困惑</strong>（例如，<code class=\"gatsby-code-text\">fred.prototype</code> 是未定义的，因为 <code class=\"gatsby-code-text\">fred</code> 不是一个函数）。个人观点，我觉得这是即便有经验的开发者也容易误解 JavaScript 原型链的最大原因。</p>\n<hr>\n<p>这篇博客很长，是吧？已经到 80% 了，坚持住。</p>\n<p>我们知道当说 <code class=\"gatsby-code-text\">obj.foo</code> 的时候，JavaScript 事实上会沿着 <code class=\"gatsby-code-text\">obj</code>, <code class=\"gatsby-code-text\">obj.__proto__</code>, <code class=\"gatsby-code-text\">obj.__proto__.__proto__</code> 等等一路寻找 <code class=\"gatsby-code-text\">foo</code>。</p>\n<p>在使用类时，你并非直接面对这一机制，但 <code class=\"gatsby-code-text\">extends</code> 的原理依然是基于这项老旧但有效的原型链机制。这也是的我们的 React 类实例能够访问如 <code class=\"gatsby-code-text\">setState</code> 这样方法的原因：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">class Greeting extends React.Component {\n  render() {\n    return &lt;p&gt;Hello&lt;/p&gt;;\n  }\n}\n\nlet c = new Greeting();\nconsole.log(c.__proto__); // Greeting.prototype\nconsole.log(c.__proto__.__proto__); // React.Component.prototype\nconsole.log(c.__proto__.__proto__.__proto__); // Object.prototype\n\nc.render();      // 在 c.__proto__ (Greeting.prototype) 上找到\nc.setState();    // 在 c.__proto__.__proto__ (React.Component.prototype) 上找到\nc.toString();    // 在 c.__proto__.__proto__.__proto__ (Object.prototype) 上找到</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>换句话说，<strong>当你在使用类的时候，实例的 <code class=\"gatsby-code-text\">__proto__</code> 链“镜像”了类的层级结构：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// `extends` 链\nGreeting\n  → React.Component\n    → Object (间接的)\n\n// `__proto__` 链\nnew Greeting()\n  → Greeting.prototype\n    → React.Component.prototype\n      → Object.prototype</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>2 条链。</p>\n<hr>\n<p>既然 <code class=\"gatsby-code-text\">__proto__</code> 链镜像了类的层级结构，我们可以检查一个 <code class=\"gatsby-code-text\">Greeting</code> 是否扩展了 <code class=\"gatsby-code-text\">React.Component</code>，我们从 <code class=\"gatsby-code-text\">Greeting.prototype</code> 开始，一路沿着 <code class=\"gatsby-code-text\">__proto__</code> 链：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// `__proto__` chain\nnew Greeting()\n  → Greeting.prototype // 🕵️ 我们从这儿开始\n    → React.Component.prototype // ✅ 找到了！\n      → Object.prototype</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>方便的是，<code class=\"gatsby-code-text\">x instanceof Y</code> 做的就是这类搜索。它沿着 <code class=\"gatsby-code-text\">x.__proto__</code> 链寻找 <code class=\"gatsby-code-text\">Y.prototype</code> 是否在那儿。</p>\n<p>通常，这被用来判断某样东西是否是一个类的实例：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">let greeting = new Greeting();\n\nconsole.log(greeting instanceof Greeting); // true\n// greeting (🕵️‍ 我们从这儿开始)\n//   .__proto__ → Greeting.prototype (✅ 找到了！)\n//     .__proto__ → React.Component.prototype\n//       .__proto__ → Object.prototype\n\nconsole.log(greeting instanceof React.Component); // true\n// greeting (🕵️‍ 我们从这儿开始)\n//   .__proto__ → Greeting.prototype\n//     .__proto__ → React.Component.prototype (✅ 找到了！)\n//       .__proto__ → Object.prototype\n\nconsole.log(greeting instanceof Object); // true\n// greeting (🕵️‍ 我们从这儿开始)\n//   .__proto__ → Greeting.prototype\n//     .__proto__ → React.Component.prototype\n//       .__proto__ → Object.prototype (✅ 找到了！)\n\nconsole.log(greeting instanceof Banana); // false\n// greeting (🕵️‍ 我们从这儿开始)\n//   .__proto__ → Greeting.prototype\n//     .__proto__ → React.Component.prototype\n//       .__proto__ → Object.prototype (🙅‍ 没找到！)</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>但这用来判断一个类是否扩展了另一个类还是有效的</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">console.log(Greeting.prototype instanceof React.Component);\n// greeting\n//   .__proto__ → Greeting.prototype (🕵️‍ 我们从这儿开始)\n//     .__proto__ → React.Component.prototype (✅ 找到了！)\n//       .__proto__ → Object.prototype</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这种检查方式就是我们判断某样东西是一个 React 组件类还是一个常规函数的方式。</p>\n<hr>\n<p>然而 React 并不是这么做的 😳</p>\n<p>关于 <code class=\"gatsby-code-text\">instanceof</code> 解决方案有一点附加说明，当页面上有多个 React 副本，并且我们要检查的组件继承自 <strong>另一个</strong> React 副本的 <code class=\"gatsby-code-text\">React.Component</code> 时，这种方法是无效的。在一个项目里混合多个 React 副本是不好的，原因有很多，但站在历史角度来看，我们试图尽可能避免问题。（有了 Hooks，我们 <a href=\"https://github.com/facebook/react/issues/13991\">或许得</a> 强制避免重复）</p>\n<p>另一点启发可以是去检查原型链上的 <code class=\"gatsby-code-text\">render</code> 方法。然而，当时还 <a href=\"https://github.com/facebook/react/issues/4599#issuecomment-129714112\">不确定</a> 组件的 API 会如何演化。每一次检查都有成本，所以我们不想再多加了。如果 <code class=\"gatsby-code-text\">render</code> 被定义为一个实例方法，例如使用类属性语法，这个方法也会失效。</p>\n<p>因此, React 为基类 <a href=\"https://github.com/facebook/react/pull/4663\">增加了</a> 一个特别的标记。React 检查是否有这个标记，以此知道某样东西是否是一个 React 组件类。</p>\n<p>最初这个标记是在 <code class=\"gatsby-code-text\">React.Component</code> 这个基类自己身上：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// React 内部\nclass Component {}\nComponent.isReactClass = {};\n\n// 我们可以像这样检查它\nclass Greeting extends Component {}\nconsole.log(Greeting.isReactClass); // ✅ 是的</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>然而，有些我们希望作为目标的类实现 <a href=\"https://github.com/scala-js/scala-js/issues/1900\">并没有</a> 复制静态属性（或设置非标准的 <code class=\"gatsby-code-text\">__proto__</code>），标记也因此丢失。</p>\n<p>这也是为什么 React 把这个标记 <a href=\"https://github.com/facebook/react/pull/5021\">移动到了</a> <code class=\"gatsby-code-text\">React.Component.prototype</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"gatsby-code-text line-numbers\"><code class=\"gatsby-code-text\">// React 内部\nclass Component {}\nComponent.prototype.isReactComponent = {};\n\n// 我们可以像这样检查它\nclass Greeting extends Component {}\nconsole.log(Greeting.prototype.isReactComponent); // ✅ 是的</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p><strong>说真的这就是全部了。</strong></p>\n<p>你或许奇怪为什么是一个对象而不是一个布尔值。实战中这并不重要，但早期版本的 Jest（在 Jest 商品化之前）是默认开始自动模拟功能的，生成的模拟数据省略掉了原始类型属性，<a href=\"https://github.com/facebook/react/pull/4663#issuecomment-136533373\">破坏了检查</a>。谢了，Jest。</p>\n<p>一直到今天，<a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300\">React 都在用</a> <code class=\"gatsby-code-text\">isReactComponent</code> 进行检查。</p>\n<p>如果你不扩展 <code class=\"gatsby-code-text\">React.Component</code>，React 不会在原型上找到 <code class=\"gatsby-code-text\">isReactComponent</code>，因此就不会把组件当做类处理。现在你知道为什么解决 <code class=\"gatsby-code-text\">Cannot call a class as a function</code> 错误的 <a href=\"https://stackoverflow.com/a/42680526/458193\">得票数最高的答案</a> 是增加 <code class=\"gatsby-code-text\">extends React.Component</code>。最后，我们还 <a href=\"https://github.com/facebook/react/pull/11168\">增加了一项警告</a>，当 <code class=\"gatsby-code-text\">prototype.render</code> 存在但 <code class=\"gatsby-code-text\">prototype.isReactComponent</code> 不存在时会发出警告。</p>\n<hr>\n<p>你或许会觉得这个故事有一点“标题党”。 <strong>实际的解决方案其实真的很简单，但我花了大量的篇幅在转折上来解释为什么 React 最终选择了这套方案，以及还有哪些候选方案。</strong></p>\n<p>以我的经验来看，设计一个库的 API 也经常会遇到这种情况。为了一个 API 能够简单易用，你经常需要考虑语义化（可能的话，为多种语言考虑，包括未来的发展方向）、运行时性能、有或没有编译时步骤的工程效能、生态的状态以及打包方案、早期的警告，以及很多其它问题。最终的结果未必总是最优雅的，但必须要是可用的。</p>\n<p><strong>如果最终的 API 成功的话, <em>它的用户</em> 永远不必思考这一过程</strong>。他们只需要专心创建应用就好了。</p>\n<p>但如果你同时也很好奇...知道它是怎么工作的也是极好的。</p>\n<blockquote>\n<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href=\"https://github.com/xitu/gold-miner\">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><a href=\"https://github.com/xitu/gold-miner\">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href=\"https://juejin.im\">掘金</a> 上的英文分享文章。内容覆盖 <a href=\"https://github.com/xitu/gold-miner#android\">Android</a>、<a href=\"https://github.com/xitu/gold-miner#ios\">iOS</a>、<a href=\"https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF\">前端</a>、<a href=\"https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF\">后端</a>、<a href=\"https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE\">区块链</a>、<a href=\"https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81\">产品</a>、<a href=\"https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1\">设计</a>、<a href=\"https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD\">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href=\"https://github.com/xitu/gold-miner\">掘金翻译计划</a>、<a href=\"http://weibo.com/juejinfanyi\">官方微博</a>、<a href=\"https://zhuanlan.zhihu.com/juejinfanyi\">知乎专栏</a>。</p>\n</blockquote>","frontmatter":{"title":"【译】React 如何区分 Class 和 Function？","description":"事情好像没那么简单","cover":{"publicURL":"/static/overreacted-9fbf74366dc5b9e4aab57572a9f0470d.jpg"},"tags":["react"],"series":"overreacted","draft":true},"fields":{"id":"how-does-react-tell-a-class-from-a-function","date":"2019-02-22T16:00:00.000Z"}}},"pageContext":{"slug":"/blog/2019/02/23/how-does-react-tell-a-class-from-a-function"}}